package webgool.server;

import gool.GOOLCompiler;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.util.HashMap;
import java.util.Map;

import javax.websocket.OnClose;
import javax.websocket.OnMessage;
import javax.websocket.OnOpen;
import javax.websocket.Session;
import javax.websocket.server.ServerEndpoint;




/**
 * The Server class does contain the listeners used by Glassfish to react to network sockets.<br>
 * It provides the convenient annotated classes and methods that Glassfish needs to properly react.<br>
 * For example, ServerEndPoint does correspond to the class that will be used by all the connection requests on WWWglassfish/domaine/appli .<br>
 * Another example is the OnMessage annotation that does execute the associated method each time an input message is detected.<br> 
 * @author Charbel FOUREL
 * @version 0.1a
 * 
 */
@ServerEndpoint("/appli")
public class Server {

	/**
	 * Executed method when a connection is established with a client.
	 * @param session - the unique Session created for the client.
	 */
	@OnOpen
	public void onOpen(Session session){
		System.out.println("INFOS: " + session.getId() + " has log in.");
	}

	/**
	 * Executed method when a message from a client is received.
	 * @param message - the message sent by the client.
	 * @param session - the unique session created for the client
	 */
	@OnMessage
	public void onMessage(String message, Session session){

		ByteArrayOutputStream consoleToString = new ByteArrayOutputStream();
		PrintStream flux = new PrintStream(consoleToString);
		System.setErr(flux);

		// Delimiter definition for parsing
		String delimiter = "[§]";

		// Table generated by the parsing
		String [] elements = message.split(delimiter);

		/* An input message will, for example, have the following structure : @§fr§Java§C++§content
		 * The parser will then create a table with:
		 * elements [0] == @
		 * elements [1] == fr
		 * elements [2] == Java
		 * elements [3] == C++
		 * elements [4] == the content to process
		 * 
		 * elements [0] is the type of the message : @ for the processing, 1 for the errors/
		 * elements [1] is the user language.
		 * elements [2] is the input computer language chosen by the user.
		 * elements [3] is the output computer language chosen by the user.
		 * elements [4] is the content of the code the user wants to process.
		 */

		if (elements[0].equals("@")) {

			String messageOut = new String("@");
			String messageErr = new String("");
			Map<String , String> tabResults = new HashMap<String, String>();

			/*
			 * An output message will, for example, have the following structure : @§contenu
			 * The parser will then give to the client the following table:
			 * elements [0] == @
			 * elements [1] == the processed content
			 * 
			 * elements [0] is the type of the message : @ for the translated content, 1 for the errors.
			 * elements [1] is the translated content.
			 */

			// For a French user
			if (elements [1].equals("fr")) {
				try {
					// translator call
					tabResults = GOOLCompiler.launchHTMLTranslation(elements[2], elements[3], elements[4]);
					// output message construction
					for (Map.Entry<String, String> entry : tabResults.entrySet()) {
						messageOut += "§" + entry.getKey() + "§" + entry.getValue();
					}
					session.getBasicRemote().sendText(messageOut); 
					messageErr = "Traitement correctement exécuté par le serveur";
				} catch(Exception e) {
					System.err.println(e);
					messageErr = consoleToString.toString();
				}
				try {
					session.getBasicRemote().sendText("1§" + messageErr);
				} catch (IOException e) {
					e.printStackTrace();
				}
			}

			// For an English user
			if (elements [1].equals("en")) {
				try {
					// translator call
					tabResults = GOOLCompiler.launchHTMLTranslation(elements[2], elements[3],
							elements[4]);
					// output message construction
					for (Map.Entry<String, String> entry : tabResults.entrySet()) {
						messageOut += "§" + entry.getKey() + "§" + entry.getValue();
					}
					session.getBasicRemote().sendText(messageOut); 
					messageErr = "Server treatment properly executed";
				} catch(Exception e) {
					System.err.println(e);
					messageErr = consoleToString.toString();
				}
				try {
					session.getBasicRemote().sendText("1§" + messageErr);
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			// references set to null for the garbage collector
			consoleToString = null;
			flux = null;
		}
	}

	/**
	 * Executed method when a socket is closed by a client.
	 * @param session - the unique session created for the client
	 */
	@OnClose
	public void onClose(Session session){
		System.out.println("INFOS: " + session.getId() + " has log out.");
	}
}



